import axios, { AxiosInstance, AxiosResponse, isAxiosError } from 'axios'
import camelCaseKeys from 'camelcase-keys'

import { ClientConfig } from './core/ClientConfig'
{{#each services}}
import { {{{name}}}Service } from './services/{{{name}}}Service.js';
{{/each}}

function applyMixins(derivedCtor: any, constructors: any[]) {
    constructors.forEach((baseCtor) => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {
            Object.defineProperty(
                derivedCtor.prototype,
                name,
                Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null),
            )
        })
    })
}

export class LuneClient {
    protected client: AxiosInstance
    protected config: ClientConfig

    constructor(
        apiKey: string,
        baseUrl: string = 'https://api.lune.co',
        apiVersion: string = '1',
        account?: string,
    ) {
        this.config = {
            BASE_URL: `${baseUrl}/v{api-version}`,
            VERSION: apiVersion,
            BEARER_TOKEN: apiKey,
            ACCOUNT: account,
        }
        this.client = axios.create()

        // Convert to camelCase when receiving request
        const camelCaseResponse = (response: AxiosResponse<unknown, unknown>) => ({
            ...response,
            // SAFETY: The camelcase-keys type definitions are overly restrictive. The function
            // handles all kinds of values just fine: arrays, numbers, strings, null etc.
            //
            // Instead of writing a bunch of type-detecting conditional code to satisfy the
            // TS compiler let's just wholesale ignore this type mismatch â€“ we don't know what
            // value do we actually deal with here but the library will handle it.
            data: camelCaseKeys(response.data as any, { deep: true }),
        })
        this.client.interceptors.response.use(camelCaseResponse, (error: unknown) => {
            // There's a separate, slightly different callback for errors.
            if (!isAxiosError(error)) {
                throw error
            }
            if (error.response) {
                error.response = camelCaseResponse(error.response)
            }
            // We need to return a rejected promise for it to work nice with axios.
            return Promise.reject(error)
        })
    }

    public setAccount(accountId: string) {
        this.config.ACCOUNT = accountId
    }
}

applyMixins(LuneClient, [
    {{#if services}}
    {{#each services}}
    {{{name}}}Service,
    {{/each}}
    {{/if}}
])

// eslint-disable-next-line no-redeclare -- mixins require same name
export interface LuneClient extends
    {{#each services}}
    {{{name}}}Service{{#unless @last}},{{/unless}}
    {{/each}} {}

{{#each models}}
{{#if @root.useUnionTypes}}
export type { {{{name}}} } from './models/{{{name}}}.js';
{{else if enum}}
export { {{{name}}} } from './models/{{{name}}}.js';
{{else if enums}}
export { {{{name}}} } from './models/{{{name}}}.js';
{{else}}
export type { {{{name}}} } from './models/{{{name}}}.js';
{{/if}}
{{/each}}

{{#each services}}
export { {{{name}}}Service } from './services/{{{name}}}Service.js';
{{/each}}
